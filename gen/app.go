// Code generated by event-source-gen. DO NOT EDIT.
package app

import (
	"context"
	"fmt"
)

type App struct {
	store    Store
	queue    EventQueue
	registry *Registry
	quit     chan struct{}
	user     *UserService
}

func NewApp() *App {
	a := &App{
		registry: NewRegistry(),
		quit:     make(chan struct{}, 1),
	}

	a.registerEvents()

	return a
}

func (a *App) SetStore(store Store) {
	a.store = store
}

func (a *App) SetQueue(queue EventQueue) {
	a.queue = queue
}

func (a *App) Close() {
	a.quit <- struct{}{}
}

func (a *App) Start(ctx context.Context) {
	var q EventQueuePull
	var ok bool
	if q, ok = a.queue.(EventQueuePull); !ok {
		return
	}

	a.startReactors(ctx)
	a.startProjections(ctx)
	go q.Start(ctx)
}

func (a *App) startReactors(ctx context.Context) {
	var q EventQueuePull
	var ok bool
	if q, ok = a.queue.(EventQueuePull); !ok {
		return
	}

	if c, ok := a.user.manager.(UserReactorManager); ok {
		a.registerReactor(ctx, q, "user.created", func(ctx context.Context, app *App, eventType string, event Eventer) {
			c.HandleWelcomeEmailReactor(ctx, app, event.(*UserCreated))
		})
	}
}

func (a *App) startProjections(ctx context.Context) {
	var q EventQueuePull
	var ok bool
	if q, ok = a.queue.(EventQueuePull); !ok {
		return
	}

	if c, ok := a.user.manager.(UserProjectionManager); ok {

		a.registerReactor(ctx, q, "user.created", func(ctx context.Context, app *App, eventType string, event Eventer) {
			c.HandleUserCreatedProjection(ctx, a, event.(*UserCreated))
		})

		a.registerReactor(ctx, q, "user.updated", func(ctx context.Context, app *App, eventType string, event Eventer) {
			c.HandleUserUpdatedProjection(ctx, a, event.(*UserUpdated))
		})
	}
}

func (a *App) Store() Store {
	return a.store
}

func (a *App) Queue() EventQueue {
	return a.queue
}

func (a *App) Registry() *Registry {
	return a.registry
}

func (a *App) registerEvents() {
	a.registry.Add(usersEvents...)
}

func (a *App) registerReactor(
	ctx context.Context,
	q EventQueuePull,
	eventType string,
	reactor func(ctx context.Context, app *App, eventType string, event Eventer),
) {
	q.Subscribe(ctx, func(ctx context.Context, event Eventer) error {
		if event.GetType() == eventType {
			reactor(ctx, a, event.GetType(), event)
		}
		return nil
	})
}

func (a *App) registerProjections(
	ctx context.Context,
	q EventQueuePull,
	reactor func(ctx context.Context, app *App, eventType string, event Eventer),
) {
	q.Subscribe(ctx, func(ctx context.Context, event Eventer) error {
		reactor(ctx, a, event.GetType(), event)
		return nil
	})
}

func (a *App) SaveAndPublish(ctx context.Context, id string, event Eventer) error {
	if err := a.store.Save(ctx, id, event); err != nil {
		return fmt.Errorf("failed to save event: %w", err)
	}

	a.queue.Publish(ctx, event)

	return nil
}
func (a *App) User() *UserService {
	return a.user
}

func (a *App) GetUserByID(ctx context.Context, id string) (*User, error) {
	events, err := a.store.Get(ctx, id)
	if err != nil {
		return nil, err
	}

	if len(events) == 0 {
		return nil, fmt.Errorf("not events found for %s", id)
	}

	builder := &UserBuilder{
		Manager: a.user.manager.(UserEventManager),
	}

	return builder.Rebuild(events), nil
}

func GetUserFromContext[T any](ctx context.Context) (T, error) {
	var u T
	var ok bool

	if u, ok = ctx.Value("user").(T); ok {
		return u, nil
	}

	return u, fmt.Errorf("user not found in context")
}
